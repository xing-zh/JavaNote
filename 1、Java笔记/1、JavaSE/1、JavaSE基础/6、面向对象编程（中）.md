# 关键字：static（静态）

## 作用范围

可以用来修饰的结构：主要用来修饰类的内部结构

属性、方法、代码块、内部类

## static修饰属性：

==静态变量（或类变量）==

### 静态属性 vs 非静态属性：

属性，是否使用static修饰，又分为：静态属性 vs 非静态属性(实例变量)

l 实例变量：我们创建了类的多个对象，每个对象都独立的拥一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。

l 静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。

### static修饰属性的其他说明：

① 静态变量随着类的加载而加载。可以通过"类.静态变量"的方式进行调用

② 静态变量的加载要早于对象的创建。

③ 由于类只会加载一次，则==静态变量在内存中也只会存在一份：存在方法区的静态域中==

### 内存解析：

![说明: untitle.png](https://gitee.com/yh-gh/img-bed/raw/master/202109181147393.gif)

## static修饰方法：

① 随着类的加载而加载，可以通过"类.静态方法"的方式进行调用

② **静态方法中，只能调用静态的方法或属性**

   非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性

## static修饰代码块：

### 静态代码块：

\>内部可以输出语句

\>**随着类的加载而执行,而且只执行一次**

\>作用：初始化类的信息

\>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行

\>静态代码块的执行要优先于非静态代码块的执行

\>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构

### 非静态代码块：

\>内部可以输出语句

\>**随着对象的创建而执行**

\>每创建一个对象，就执行一次非静态代码块

\>作用：可以在创建对象时，对对象的属性等进行初始化

\>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行

\>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法

## static的注意点：

==在静态的方法内，不能使用this关键字、super关键字==

### 什么时候使用static

属性：

* 属性是可以被多个对象所共享的，不会随着对象的不同而不同的。

* 类中的常量也常常声明为static

方法：

* 操作静态属性的方法，通常设置为static的

* 工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections

## main方法

1. 作为程序的入口出现

2. main()方法也是一个普通的静态方法

3. main()方法可以作为我们与控制台交互的方式。（之前：使用Scanner）

# 面向对象特征二：继承性

extends：延展、扩展

## 格式：

class A extends B{}

l A:子类、派生类、subclass

l B:父类、超类、基类、superclass

## 子类继承父类以后有哪些不同？

* 体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的==所有的属性和方法==。
* 特别的，父类中声明为private的属性或方法`不能被子类继承`，子类继承父类以后，仍然认为获取了父类中私有的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。
* 子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。
* 子类和父类的关系，不同于子集和集合的关系。
* `Default`或`friendly`声明的成员，仅能够被同一个包中的子类继承

## Java中继承性的说明

1. 一个类可以被多个子类继承。

2. Java中类的单继承性：一个类只能有一个父类

3. 子父类是相对的概念。

4. 子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类

5. 子类继承父类以后，就获取了直接父类以及所间接父类中声明的属性和方法

## 方法重写：

override 或 overwrite

子类继承父类以后，可以对父类中同名同参数的方法，进行**覆盖操作**

重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。

例如

```java
class Circle{
	public double findArea(){}//求面积
}
class Cylinder extends Circle{
	public double findArea(){}//求表面积
}
**************************************
class Account{
	public boolean withdraw(double amt){}
}
class CheckAccount extends Account{
	public boolean withdraw(double amt){}
}
```

### 重写的规则：

权限修饰符 返回值类型 方法名(形参列表) throws 异常的类型{

​         //方法体

}

约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法

① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同

② ==子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符==

* 特殊情况：==子类不能重写父类中声明为private、static、final的方法==

③ 返回值类型：

* 父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void

* 父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类

* 父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)

④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型

## super关键字

super 关键字可以理解为：父类的

可以用来调用的结构：==属性、方法、构造器==

### super调用属性、方法：

* 我们可以在子类的方法或构造器中。通过使用"super.属性"或"super.方法"的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略"super."
* 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用"super.属性"的方式，表明调用的是父类中声明的属性。

### super调用构造器（即构造方法）： 

* 我们可以在子类的构造器（构造方法）中显式的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器

* =="super(形参列表)"的使用，必须声明在子类构造器的首行！==

* 我们在类的构造器中，==针对于"this(形参列表)"或"super(形参列表)"只能二选一==，不能同时出现

* 在构造器的首行，没显式的声明"this(形参列表)"或"super(形参列表)"，则默认调用的是父类中空参的构造器：super()

* 在类的多个构造器中，至少一个类的构造器中使用了"super(形参列表)"，调用父类中的构造器 

## 类的初始化顺序：  

1. **加载父类**（给父类的静态属性开辟空间、赋默认值、赋初始值，执行静态块）

2. **加载子类**（给子类的静态属性开辟空间、赋默认值、赋初始值，执行静态块）

以下是在创建子类对象的时候才会发生：

3. **对父类中定义的非静态属性分配空间**，赋默认值，做初始化（执行父类中定义的初始化块，执行父类的构造方法）

注意：默认执行的是父类的无参数的构造方法，如果在子类中使用super显示的调用了父类的其他构造方法，无参的就不会再次被调用

4.  **对子类中定义的非静态属性进行初始化**（执行子类中定义的初始化块，执行子类中定义的构造方法，创建子类对象）

# 关键字：abstract（抽象的）

可以用来修饰：**==类、方法==**

==**不可以和private、static、final、一起使用，不可以修饰构造器**==

> 当子类继承抽象类时，需要实现所有的抽象类的方法，否则子类也要声明为抽象类。

## abstract修饰类：抽象类

* ==此类不能实例化==
* 抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）
* 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作 --->抽象的使用前提：继承性
* 抽象类不能实例化，即不能用new来实例化抽象类
* 抽象类的意义：为子类提供模板，让子类实现

## abstract修饰方法：抽象方法

* 抽象方法只有方法的声明，没方法体

* ==包含抽象方法的类，一定是一个抽象类。==反之，抽象类中可以没有抽象的方法。

* 若子类重写了父类中的所的抽象方法后，此子类方可实例化

* 父类没有实现的，子类必须实现，若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰  

* 抽象类中可以有普通方法、构造方法、属性。但是构造方法不能用new来实例化，只能被子类调用

  # 面向对象特征三：多态性(polymorphism)

可以理解为一个事物的多种形态。  

方法的多态。 

对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）        

## 多态性的使用：虚拟方法调用   

* 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。

* ==总结：编译，看左边；运行，看右边。==

**对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）**    

## 向上转型：

==多态性==

## 向下转型：

### 为什么使用向下转型：

* 有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。如何才能调用子类特的属性和方法？使用向下转型。

### 如何实现向下转型：

* 使用强制类型转换符：()

### 使用时的注意点：

* 使用强转时，可能出现==ClassCastException==的异常。

* 为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行**instanceof**的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。

### instanceof 的使用：

* **a instanceof A** : 判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false。

* 类B是类A的父类：a instanceof A返回true,a instanceof B也返回true