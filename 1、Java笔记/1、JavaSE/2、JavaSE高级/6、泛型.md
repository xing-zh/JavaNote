# 泛型的概念

所谓泛型，就是==允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型==。这个类型参数将在使用（例如，继承或实现这个接口，用这个类型声明变量、创建对象时确定（即传入实际的类型参数，也称为类型实参）。

==**JDK1.5引入**==

泛型的定义中，**不可以使用基本数据类型**，可以**使用对应的包装类进行替换**

> 帮助我们建立类型安全的集合

# 可避免的问题

1、类型不安全，导入数据存入混乱，添加泛型，在编译时就会进行类型检查，保证了数据安全

2、避免了强制类型转换时，出现异常`ClassCastException `

# 泛型的使用

`List<String> li = new ArrayList<String>();`

1、在实例化集合类时，可以指明具体的泛型类型

2、指明完泛型以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。

3、如果实例化时，没指明泛型的类型。默认类型为java.lang.Object类型。

4、泛型可以嵌套使用

5、JDK7新特性，类型推断，可以写成：

`List<String> li = new ArrayList<>();`

## 泛型类

```java
修饰符 class 类名<泛型形参1，泛型形参2，......> {
    在类中使用泛型形参对类型进行占位;
}
```

泛型形参名称，一般由单个大写字母组成，常用的：E、T、V、N、K

如果泛型类在实例化的时候没有指明泛型的类型，那么默认的类型就是Object类型，**如果实例化的类是带有泛型的，那么建议在实例化的时候指明类的泛型**

* ==泛型不同的两个引用不可以互相赋值==
* 在类、接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型，但==在静态方法中不能使用类的泛型==。
* 异常类不能是泛型的
* **如果子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型。**
* 子类除了指定或保留父类的泛型，还可以增加自己的泛型

## 泛型接口

```java
修饰符 interface 类名<泛型形参> {
    在接口中使用泛型形参对类型进行占位;
}
```

## 泛型方法

泛型方法是指在方法中出现了泛型的结构，泛型参数与类的泛型参数没任何关系和类是不是泛型类也没有关系。

可以声明为静态的。原因：**泛型参数是在调用方法时确定的**。并非在实例化类时确定。

```java
public <E> List<E> 方法名(E[] arr){
    方法体;
}
```

## 泛型在继承方面的体现

类A是类B的父类，**G<A>和G<B>不具备子父类关系**，属于并列关系

![说明: clipboard.png](https://gitee.com/yh-gh/img-bed/raw/master/202109181153179.gif)

![说明: clipboard.png](https://gitee.com/yh-gh/img-bed/raw/master/202109181153386.gif)

# 通配符

==**通配符：?**==

类A是类B的父类，`G<A>`和`G<B>`是没关系的，二者共同的父类是：`G<?>`

以List<?>数据的读写为例：

l 读取List的对象list中的元素时，永远是数据安全的，因为**不管list的元素真实类型是什么，它都是Object类型**。

l 对于写入list中的元素时，由于因为我们不知道c的元素类型，我们**不能向其中添加对象**。

l 在写入元素时，唯一的例外是null，它是所有类型的成员

## 限制的通配符

```java
//? extends A:相当于小于等于，可以放A和A的子类，所以在接收的时候，可以使用A或A的父类进行接收
    G<? extends A> 可以作为G<A>和G<B>的父类，其中B需要是A的子类
//? super A:相当于大于等于，可以放A和A的父类，所以，在接收的时候，也只可以使用Object类型接收
    G<? super A> 可以作为G<A>和G<B>的父类，其中B需要是A的父类
```

**? extends A**：不可以进行写入，因为写入的类型无法确定，继承关系的限制。

**? super A**：可以写入A以及A的子类，因为其代表A或A的父类，所以父类肯定可以指向子类