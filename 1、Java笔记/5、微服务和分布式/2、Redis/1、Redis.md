# 数据库概述

数据库分为关系型数据库，非关系型数据库

关系型数据库：MySQL，SqlServer，Oracle，DB2，pgSQL

非关系数据库：MongDB，Redis，Hbase，ElasticSearch

## 关系型数据库的缺陷

1. 关系型数据库关注于表与表之间，数据与数据之间的关系
2. 关系型数据库在查询数据时，效率相对而言比较低下（从硬盘中读取数据）
3. 关系型数据库表在设计的时候，结构化太固定，太单一（数据类型固定）
4. 关系型数据库在动态修改表结构，数据结构时是非常麻烦的（代价非常高昂）

## 非关系型数据库的优势

1. 性能较高，主要体现在它几乎都是直接从内存中获取数据
2. key - value结构简单，变化难度较小，只需要修改value的结构即可
3. 数据类型丰富，既可以支持字符串，也可以支持对象，还可以支持视频，图片，音频

## 关系型数据库和非关系型数据库的区别（面试题）

1. 关系型数据库，它的结构是以表的方式进行存储，数据是以行，列的方式进行展示，它更关注的表和表，数据和数据之间的关系；非关系型数据库，它的结构大多都是以及k-v结构的方式来进行存储，数据没有固定的结构，它更多的是关注数据的存储
2. 关系型数据库的数据通常是存储在硬盘中的文件，存储数据都是在操作该文件；而非关系型数据库的数据，通常都是存储在内存中的，当然，它们也有它们自己的持久化机制

# Redis的概述

1. Redis**属于非关系型数据库（NoSQL）**。它们不保证关系数据的ACID特性。
2. Redis是一个基于key-value，基于内存的，可以持久化的数据库，支持分布式，而且Redis是单线程的（避免了线程切换对CPU的消耗），而且是基于NIO的
3. `NoSQL != NOT SQL`，而是**NOT Only SQL**
4. 系统中需要具备维护关系的关系数据库，也要有专门维护数据的非关系数据库
5. 非关系型数据库实际上是对关系型的一种补充

## Redis的优势

1. 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s
2. 丰富的数据类型 – Redis支持二进制格式的 String, List, Hash, Set 及 Ordered Set数据类型等操作
3. 原子性 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来
4. 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性

# 数据类型

此处的数据类型说的是value的数据，key的类型始终为String

### 基础数据类型

1. **String**
2. **List**
3. **Set**
4. **Zset（有序集合）**
5. **Hash**

### 扩展数据类型

1. **GEO**（地理信息定位）
2. **Bitmaps**（位图）
3. **HypeLogLog**

# Redis的使用场景

1. 做为应用程序的状态服务器，例如：将JWT所产生的令牌进行存储，session
2. 做为高热点数据的缓存服务器，例如：淘宝：产品类型，微博：明星发布的动态
3. 做系统分析后的数据的存储服务器，例如：报表数据，游戏（战力榜，等级榜，充值榜……）

![说明: clipboard.png](https://gitee.com/yh-gh/img-bed/raw/master/202109181346303.gif)

## 具体场景

1. 缓存，毫无疑问这是Redis当今最为人熟知的使用场景。再提升服务器性能方面非常有效
2. 排行榜，如果使用传统的关系型数据库来做这个事儿，非常的麻烦，而利用Redis的SortSet数据结构能够非常方便搞定
3. 计算器/限速器，利用Redis中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力
4. 好友关系，利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能
5. 简单消息队列，除了Redis自身的发布/订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦
6. Session共享，以PHP为例，默认Session是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息
7. 电商秒杀场景，优惠劵抢购场景
8. 发送短信验证码（服务器存储验证码，用户提交收到的验证码，进行比对）

 

 

 

 

 

 

 

 

 