### 1、数据库的三范式是什么

第一范式：表中字段具有原子性，不可再分

第二范式：满足第一范式，要求表中每个实例或每行必须被唯一区分，通常需要为表加上一列，存储各个实例的唯一标识，主键，如果主键是复合主键，除了主键以外的其他列必须完全依赖于主键列，不能只依赖于主键的一部分

第三范式：满足第二范式，表中不包含已在其他表中已包含的非主关键字信息，表中的的其他列必须直接依赖主键，不可以间接依赖

### 2、数据库优化方面的经验

①使用PreparedStatement，一般来说比Statement性能高，因为一个sql发送到服务器去执行，涉及到语法检查、语义分析、编译、缓存等

②有外键约束会影响插入和删除的性能，所以如果程序能够保证数据完整性的情况下，那么在设计数据库的时候，就去掉外键约束



### 3、简述常用的索引都有哪些种类

普通索引：针对数据库表创建索引

唯一索引：与普通索引类似，不同就是MySQL数据库索引列的值必须唯一，但是允许为空值

主键索引：是一种特殊的唯一索引，不允许为空值，一般在建表的时候创建主键索引

组合索引：为了进一步压榨MySQL效率，就要考虑建立组件索引，就是将数据库表的多个字段联合起来作为一个组合索引

### 4、在mysql数据库中索引的工作机制是什么

数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询，更新数据库表中的数据，索引的实现通常使用B树及其变种B+树

### 5、MySQL基础操作命令

MySQL是否处于运行状态：service mysqld status

开启MySQL服务：service mysqld start

停止MySQL服务：service mysqld stop

登入MySQL：mysql -u root -p

列出所有的数据库：show databases

切换到某个数据库：use databasename

列出某个数据库所有表：show tables

获取表内所有Field对象的名称和类型：describe table_name

### 6、MySQL复制原理以及流程

mysql内建的复制功能是构建大型，高性能应用程序的基础。将mysql的数据分布到多个系统上去，这种分布的机制，是通过将mysql的某一台主机的数据复制到其他主机上，并重新执行一遍来实现的。复制过程中一个服务器充当主服务器，而一个或多个其他服务器充当服务器。主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环。这些日志可以记录发送到从服务器的更新。当一个从服务器连接主服务器时，他通知主服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新。过程如下1、主服务器把更新记录到二级制文件中2、从服务器把主服务器的二级制文件拷贝到自己的中继日志中3、从服务器重做中继日志中的事件，把更新应用到自己的数据库上

### 7、mysql支持的复制类型

①基于语句的复制：在主服务器上执行的SQL语句，在从服务器上执行同样的语句，MySQL默认采用基于语句的复制，效率比较高。一旦发现没法精确赋值时，会自动选择基于行的复制

②基于行的复制：把改变的内容复制获取，而不是把命令在从服务器上执行一遍，从mysql5.0开始支持

③混合类型的复制：默认采用基于语句的复制，一旦发现基于语句的复制无法精确复制时，就只采用基于行的复制

### 8、mysql中varchar和char的区别，以及varchar(50)中，50代表的含义

varchar和char的区别是，char是一种固定长度的类型，varchar是可变长度的类型

varchar(50)中的50，是表明最多可以存放50个字节

### 9、mysql中InnoDB支持的四种事务隔离级别的名称，以及区别

①Read Uncommitted读取未提交，该隔离级别，所有的事务都可以看到其他未提交事务的执行结果，这个隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少，读取未提交的数据，也被称为脏读

②Read Committed读取已提交，这是大多数数据库默认的隔离级别，但不是MySQL的，他满足了隔离的简单定义：一个事务只可以看到已经提交事务所做的改变，这种隔离级别支持所谓的不可重复度，因为同一事务的其他实例在该实例处理期间可能会有新的commit，所以同一个select可能返回不同的结果

③Repeatable Read可重复读，这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据，不过在理论上，这会导致另一个问题，幻读：幻读是指当前用户读取某一范围的数据行时，另一个事务在该范围内插入了新行，当用户再读取该范围的数据行时，会发现新的幻影行

④Serializable可串行化，这是最高的隔离级别，他通过强制事务排序，使之不可能互相冲突，从而解决幻读问题，简而言之，就是在每个读的数据行上加上共享锁，但是这个级别可能会导致大量的超时现象和锁竞争

### 10、InnoDB与MyIsam的区别

1. InnoDB支持事务，支持外键；而MyIsam不支持事务，不支持外键
2. InnoDB由于受到事务和外键的影响，所以对数据的存储以及查询效率偏低；MyIsam相反偏高
3. InnoDB在存储时，表文件是2个：frm，ibd；而MyIsam是3个文件，分别存储frm，MYD，MYI
4. InnoDB是MYSQL 5.5之后的默认存储引擎；而MyIsam是5.5之前的默认存储引擎

### 11、表中有大字段X（例如：text类型），且字段X不会经常更新，以读为主，将该字段拆成子表的好处是什么

如果字段里面有大字段（text、blob）类型的，而且这些字段的访问并不多，这时候放在一起就变成了缺点了。MySQL数据库的记录存储是按行存储的，数据块的大小又是固定的（16K），每条记录越小，相同的块存储的记录就越多。此时应该把大字段拆走，这样应付大部分小字段的查询时，就可以提高效率。当需要查询大字段的时候，此时的关联查询是不可避免的，但也是值得的。拆开后，对字段的Update就要Update多个表了

### 12、MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的

InnoDB的行锁是通过给索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应的数据行进行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁

### 13、如果一张表只有一个字段VARCHAR(N)类型，utf8编码，则N最大值为多少（精确到数量级即可）

由于utf8的每个字符最多占用3个字节。而MySQL定义行的长度不能超过65535，因此N的最大值计算方法为：`(65535-1-2)/3`。减去1的原因是实际存储从第二个字节开始，减去2的原因是因为要在列表长度存储实际的字符长度，除以3是因为utf8限制。

### 14、`select *`和`select 全部字段`两种写法的优缺点

①前者需要解析数据字典，后者不需要

②结果输出顺序，前者与建表列顺序相同，后者按指定字段顺序

③表字段改名，前者不需要修改，后者需要修改

④后者可以建立索引进行优化，前者无法优化

⑤后者的可读性比前者高

### 15、having字句和where的异同点

①语法上，where用于表中列名，having用于select结果别名

②影响结果范围：where从表读出数据的行数，having返回客户端的行数

③索引：where可以使用索引，having不可以使用索引，只能在临时结果集操作

④where后面不可以使用聚合函数，having专门使用聚合函数的

### 16、MySQL当记录不存在时insert，当记录存在时update，语句怎么写

`insert into table (a,b,c) values (1,2,3) on duplicate key update c=c+1`

### 17、MySQL的insert和update的select语法

`insert into sutdent (sid,sname) select 10,'xzm' from stu`

`update A inner join(select id,name from B) c on A.id = c.id set A.name = c.name`

